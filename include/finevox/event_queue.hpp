#pragma once

/**
 * @file event_queue.hpp
 * @brief Three-queue event architecture and UpdateScheduler
 *
 * Design: [24-event-system.md] ยง24.6 Three-Queue, ยง24.13 UpdateScheduler
 * Outbox consolidation: keyed by (BlockPos, EventType)
 */

#include "finevox/block_event.hpp"
#include "finevox/position.hpp"

#include <unordered_map>
#include <vector>
#include <queue>
#include <functional>
#include <random>
#include <chrono>
#include <mutex>
#include <condition_variable>
#include <atomic>

namespace finevox {

// Forward declarations
class World;
class SubChunk;
class BlockContext;

// ============================================================================
// EventOutbox - Staging area for handler-generated events with consolidation
// ============================================================================

/**
 * @brief Staging area for events generated by block handlers
 *
 * Events pushed to the outbox are consolidated by BlockPos before being
 * transferred to the inbox for processing. This prevents unbounded queue
 * growth when handlers generate many events for the same block.
 *
 * Consolidation rules:
 * - NeighborChanged: Merge face masks (OR together)
 * - Same event type at same position: Keep most recent, merge applicable fields
 * - Different event types: Keep higher priority event
 *
 * Thread safety: NOT thread-safe. Intended for single-threaded event loop use.
 */
class EventOutbox {
public:
    /**
     * @brief Push an event to the outbox
     *
     * If an event already exists for this position, the events are merged
     * according to consolidation rules.
     */
    void push(BlockEvent event);

    /**
     * @brief Transfer all pending events to a vector (for inbox swap)
     *
     * Clears the outbox after transfer.
     * @param inbox Vector to receive the events
     */
    void swapTo(std::vector<BlockEvent>& inbox);

    /**
     * @brief Get number of pending events (after consolidation)
     */
    [[nodiscard]] size_t size() const { return pending_.size(); }

    /**
     * @brief Check if outbox is empty
     */
    [[nodiscard]] bool empty() const { return pending_.empty(); }

    /**
     * @brief Clear all pending events
     */
    void clear() { pending_.clear(); }

private:
    // Key for outbox: (BlockPos, EventType)
    // Different event types at same position are kept separate
    struct EventKey {
        BlockPos pos;
        EventType type;

        bool operator==(const EventKey& other) const {
            return pos.x == other.pos.x && pos.y == other.pos.y &&
                   pos.z == other.pos.z && type == other.type;
        }
    };

    // Hash function for EventKey
    struct EventKeyHash {
        size_t operator()(const EventKey& key) const {
            size_t h = std::hash<int32_t>{}(key.pos.x);
            h ^= std::hash<int32_t>{}(key.pos.y) + 0x9e3779b9 + (h << 6) + (h >> 2);
            h ^= std::hash<int32_t>{}(key.pos.z) + 0x9e3779b9 + (h << 6) + (h >> 2);
            h ^= std::hash<uint8_t>{}(static_cast<uint8_t>(key.type)) + 0x9e3779b9 + (h << 6) + (h >> 2);
            return h;
        }
    };

    /**
     * @brief Merge two events of the same type at the same position
     *
     * @param existing The event already in the outbox
     * @param incoming The new event being pushed
     * @return Merged event
     */
    static BlockEvent mergeEvents(const BlockEvent& existing, const BlockEvent& incoming);

    std::unordered_map<EventKey, BlockEvent, EventKeyHash> pending_;
};

// ============================================================================
// ScheduledTick - Entry in the scheduled tick priority queue
// ============================================================================

/**
 * @brief A scheduled tick for a specific block at a specific time
 *
 * Used in a min-heap priority queue, ordered by targetTick.
 */
struct ScheduledTick {
    BlockPos pos;
    uint64_t targetTick;  // Game tick when this should fire
    TickType type;        // Type of tick (Scheduled or Repeat)

    // Min-heap ordering: earlier ticks first
    bool operator>(const ScheduledTick& other) const {
        return targetTick > other.targetTick;
    }
};

// ============================================================================
// UpdateScheduler - Manages tick scheduling and event processing
// ============================================================================

/**
 * @brief Central scheduler for game ticks, random ticks, and scheduled ticks
 *
 * Implements the three-queue architecture:
 * - Input queue: external events (player actions) + timer alarms
 * - Inbox: events being processed
 * - Outbox: events generated by handlers (consolidating)
 *
 * Thread safety: External input methods are thread-safe. Event processing
 * must happen on a single thread.
 */
class UpdateScheduler {
public:
    explicit UpdateScheduler(World& world);
    ~UpdateScheduler();

    // ========================================================================
    // Configuration
    // ========================================================================

    /**
     * @brief Set tick configuration
     */
    void setTickConfig(const TickConfig& config);

    /**
     * @brief Get current tick configuration
     */
    [[nodiscard]] const TickConfig& tickConfig() const { return config_; }

    /**
     * @brief Get current game tick number
     */
    [[nodiscard]] uint64_t currentTick() const { return currentTick_; }

    // ========================================================================
    // Scheduled Ticks (called by BlockContext)
    // ========================================================================

    /**
     * @brief Schedule a one-time tick for a block
     * @param pos Block position
     * @param ticksFromNow Number of game ticks until the tick fires
     * @param type Tick type (Scheduled or Repeat)
     */
    void scheduleTick(BlockPos pos, int ticksFromNow, TickType type);

    /**
     * @brief Cancel all scheduled ticks for a block position
     *
     * Called when a block is broken to prevent orphaned ticks.
     * Note: This is O(n) where n is total scheduled ticks - use sparingly.
     */
    void cancelScheduledTicks(BlockPos pos);

    /**
     * @brief Check if a block has any pending scheduled ticks
     */
    [[nodiscard]] bool hasScheduledTick(BlockPos pos) const;

    // ========================================================================
    // External Event Input (thread-safe)
    // ========================================================================

    /**
     * @brief Push an external event (from player input, network, etc.)
     *
     * Thread-safe: Can be called from any thread.
     */
    void pushExternalEvent(BlockEvent event);

    // ========================================================================
    // Event Processing (single-threaded)
    // ========================================================================

    /**
     * @brief Process events until stable
     *
     * Processes all pending events from input queue, inbox, and outbox
     * until all queues are empty. Then returns.
     *
     * Call this from the game loop at regular intervals.
     *
     * @return Number of events processed
     */
    size_t processEvents();

    /**
     * @brief Advance the game tick and generate tick events
     *
     * Call this at regular intervals (typically 20Hz / 50ms).
     * Generates game tick events for registered blocks and random ticks.
     */
    void advanceGameTick();

    /**
     * @brief Get the outbox for handlers to push events
     *
     * Handlers call outbox().push() to generate follow-up events.
     */
    [[nodiscard]] EventOutbox& outbox() { return outbox_; }

    // ========================================================================
    // Statistics
    // ========================================================================

    [[nodiscard]] size_t scheduledTickCount() const { return scheduledTicks_.size(); }
    [[nodiscard]] size_t pendingEventCount() const;
    [[nodiscard]] size_t deferredEventCount() const;

    // ========================================================================
    // Deferred Events (for cross-chunk updates to unloaded chunks)
    // ========================================================================

    /**
     * @brief Set callback to request chunk loading
     *
     * When a BlockUpdate targets an unloaded chunk, this callback is invoked
     * to request the chunk be loaded. The callback should trigger async load.
     *
     * @param callback Function taking ColumnPos to load
     */
    void setChunkLoadCallback(std::function<void(ColumnPos)> callback);

private:
    World& world_;
    TickConfig config_;
    uint64_t currentTick_ = 0;

    // Random number generator for random ticks
    std::mt19937 rng_;

    // Scheduled ticks priority queue (min-heap by targetTick)
    std::priority_queue<ScheduledTick, std::vector<ScheduledTick>,
                        std::greater<ScheduledTick>> scheduledTicks_;

    // Three-queue architecture
    std::vector<BlockEvent> inbox_;
    EventOutbox outbox_;

    // External input queue (thread-safe)
    std::vector<BlockEvent> externalInput_;
    mutable std::mutex externalMutex_;

    // Deferred events (for cross-chunk updates to unloaded chunks)
    // These are checked every game tick to see if target chunks are now loaded
    std::vector<BlockEvent> deferredEvents_;

    // Callback to request chunk loading
    std::function<void(ColumnPos)> chunkLoadCallback_;

    // Process a single event (returns true if processed, false if deferred)
    bool processEvent(const BlockEvent& event);

    // Process deferred events whose chunks are now loaded
    void processDeferredEvents();

    // Generate game tick events for all registered blocks
    void generateGameTickEvents();

    // Generate random tick events
    void generateRandomTickEvents();

    // Process scheduled ticks that are due
    void processScheduledTicks();

    // Drain external input into inbox
    void drainExternalInput();
};

}  // namespace finevox
