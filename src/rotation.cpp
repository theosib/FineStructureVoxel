#include "finevox/rotation.hpp"
#include <unordered_map>

namespace finevox {

// Identity rotation
const Rotation Rotation::IDENTITY{};

// Rotation matrices for 90 degree rotations around each axis
// Right-hand rule: positive rotation is counterclockwise when looking down the axis

// X-axis rotations (Y and Z swap)
const Rotation Rotation::ROTATE_X_90{{{
    {1, 0, 0},
    {0, 0, -1},
    {0, 1, 0}
}}};

const Rotation Rotation::ROTATE_X_180{{{
    {1, 0, 0},
    {0, -1, 0},
    {0, 0, -1}
}}};

const Rotation Rotation::ROTATE_X_270{{{
    {1, 0, 0},
    {0, 0, 1},
    {0, -1, 0}
}}};

// Y-axis rotations (X and Z swap) - most common for horizontal rotation
const Rotation Rotation::ROTATE_Y_90{{{
    {0, 0, 1},
    {0, 1, 0},
    {-1, 0, 0}
}}};

const Rotation Rotation::ROTATE_Y_180{{{
    {-1, 0, 0},
    {0, 1, 0},
    {0, 0, -1}
}}};

const Rotation Rotation::ROTATE_Y_270{{{
    {0, 0, -1},
    {0, 1, 0},
    {1, 0, 0}
}}};

// Z-axis rotations (X and Y swap)
const Rotation Rotation::ROTATE_Z_90{{{
    {0, -1, 0},
    {1, 0, 0},
    {0, 0, 1}
}}};

const Rotation Rotation::ROTATE_Z_180{{{
    {-1, 0, 0},
    {0, -1, 0},
    {0, 0, 1}
}}};

const Rotation Rotation::ROTATE_Z_270{{{
    {0, 1, 0},
    {-1, 0, 0},
    {0, 0, 1}
}}};

// All 24 rotations generated by composing basic rotations
// We generate them systematically to ensure we get exactly 24 unique rotations
static std::array<Rotation, 24> generateAllRotations() {
    std::array<Rotation, 24> rotations;
    int count = 0;

    // Check if rotation is already in our list
    auto isDuplicate = [&](const Rotation& r) {
        for (int i = 0; i < count; ++i) {
            if (rotations[i] == r) return true;
        }
        return false;
    };

    // Add a rotation if it's new
    auto tryAdd = [&](const Rotation& r) {
        if (!isDuplicate(r) && count < 24) {
            rotations[count++] = r;
        }
    };

    // Start with identity
    tryAdd(Rotation::IDENTITY);

    // Generate by composing X, Y, Z rotations
    const Rotation* xRots[] = {&Rotation::IDENTITY, &Rotation::ROTATE_X_90,
                               &Rotation::ROTATE_X_180, &Rotation::ROTATE_X_270};
    const Rotation* yRots[] = {&Rotation::IDENTITY, &Rotation::ROTATE_Y_90,
                               &Rotation::ROTATE_Y_180, &Rotation::ROTATE_Y_270};
    const Rotation* zRots[] = {&Rotation::IDENTITY, &Rotation::ROTATE_Z_90,
                               &Rotation::ROTATE_Z_180, &Rotation::ROTATE_Z_270};

    for (auto* rx : xRots) {
        for (auto* ry : yRots) {
            for (auto* rz : zRots) {
                tryAdd(rx->compose(*ry).compose(*rz));
            }
        }
    }

    return rotations;
}

static const std::array<Rotation, 24> ALL_ROTATIONS = generateAllRotations();

const Rotation& Rotation::byIndex(uint8_t index) {
    return ALL_ROTATIONS[index % 24];
}

uint8_t Rotation::index() const {
    for (uint8_t i = 0; i < 24; ++i) {
        if (ALL_ROTATIONS[i] == *this) {
            return i;
        }
    }
    return 0;  // Should never happen for valid rotation
}

Face Rotation::apply(Face face) const {
    // Get the normal vector for the face
    auto normal = faceNormal(face);

    // Apply rotation to the normal
    auto rotated = apply(normal[0], normal[1], normal[2]);

    // Convert back to face
    if (rotated[0] == 1)  return Face::PosX;
    if (rotated[0] == -1) return Face::NegX;
    if (rotated[1] == 1)  return Face::PosY;
    if (rotated[1] == -1) return Face::NegY;
    if (rotated[2] == 1)  return Face::PosZ;
    if (rotated[2] == -1) return Face::NegZ;

    return face;  // Should never happen
}

Rotation Rotation::compose(const Rotation& other) const {
    std::array<std::array<int8_t, 3>, 3> result{};

    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            result[i][j] = static_cast<int8_t>(
                matrix_[i][0] * other.matrix_[0][j] +
                matrix_[i][1] * other.matrix_[1][j] +
                matrix_[i][2] * other.matrix_[2][j]
            );
        }
    }

    return Rotation(result);
}

Rotation Rotation::inverse() const {
    // For rotation matrices, inverse = transpose
    std::array<std::array<int8_t, 3>, 3> result{};

    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            result[i][j] = matrix_[j][i];
        }
    }

    return Rotation(result);
}

}  // namespace finevox
